<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pyinference.inference package &mdash; pyinference 0.4.0 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.4.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="pyinference 0.4.0 documentation" href="index.html" />
    <link rel="up" title="pyinference package" href="pyinference.html" />
    <link rel="prev" title="pyinference.fuzzy package" href="pyinference.fuzzy.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="pyinference.fuzzy.html" title="pyinference.fuzzy package"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">pyinference 0.4.0 documentation</a> &raquo;</li>
          <li><a href="pyinference.html" accesskey="U">pyinference package</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="pyinference-inference-package">
<h1>pyinference.inference package<a class="headerlink" href="#pyinference-inference-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-pyinference.inference.factor">
<span id="pyinference-inference-factor-module"></span><h2>pyinference.inference.factor module<a class="headerlink" href="#module-pyinference.inference.factor" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pyinference.inference.factor.Factor">
<em class="property">class </em><tt class="descclassname">pyinference.inference.factor.</tt><tt class="descname">Factor</tt><big>(</big><em>name=''</em>, <em>cond=None</em>, <em>cons=None</em><big>)</big><a class="reference internal" href="_modules/pyinference/inference/factor.html#Factor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyinference.inference.factor.Factor" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Фактор логического вывода.</p>
<p>Фактор связывает несколько переменных в совместное распределение вероятности.</p>
<p>Фактор это некая функция, которая ставит в соответствие каждому возможному набору значений некого множества
переменных действительное число (значение фактора). Набор соответствующих значений A некоторого множества
переменных V называется назначением (assignment), если:
- мощность множества A равна мощности множества V;
- каждый элемент множества A является элементом множества значений соответствующего элемента множества V</p>
<p>Пример: допустим, M – бинарная переменная M=(“монета”, {“орел”, “решка”}), а V – набор переменных V={M}3={M, M, M},
тогда А={“орел”, “орел”, “решка”} – корректное назначение, а А1={“решка”, “решка”} – некорректное назначение,
так как не указано значение третьей переменной. А2={“решка”, “решка”, “ребро”} – также не является корректным
назначением, так как третий элемент («ребро») отсутствует в области определения третьей переменной M. Однако,
назначение А2 является корректным для множества V’={M, M, M’}, где M’=(“другая монета”, {“орел”, “решка”, “ребро”}),
так как теперь третья переменная во множестве V’ уже другая и она содержит значение «ребро» в своей области
определения. По тем же причинам, назначение А2 является корректным для набора V’’={M’, M’, M’}.</p>
<p>Таким образом, фактор определяется упорядоченной тройкой F=(N, V, X), где N – имя фактора, V – область определения
фактора (набор переменных, на которых определен фактор), X – множество значений фактора соответствующей мощности.</p>
<p>Фактор определен на некотором упорядоченном множестве переменных, называемом областью определения (scope) фактора.
Область определения обозначается так: F(A,B,C) или так: scope(F)={A,B,C}, где F – фактор, A, B и C – переменные,
входящие в фактор. Заметим, что определение фактора не накладывает никаких ограничений ни на отдельные значения,
ни на сумму этих значений, несмотря на то, что теория вероятности предусматривает такие ограничения. Фактор – это
базовый строительный блок в вероятностных графических моделях. и представление вероятностей – всего лишь одно из
возможных применений факторов. Например, определим фактор на одной переменной M, следующим образом:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">coin_var</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;coin&quot;</span><span class="p">,</span> <span class="n">terms</span><span class="o">=</span><span class="p">[</span><span class="s">&quot;орел&quot;</span><span class="p">,</span> <span class="s">&quot;решка&quot;</span><span class="p">])</span>
<span class="n">coin_factor</span> <span class="o">=</span> <span class="n">Factor</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;coin&quot;</span><span class="p">,</span> <span class="n">cons</span><span class="o">=</span><span class="p">[</span><span class="n">coin_var</span><span class="p">])</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="n">coin_factor</span><span class="o">.</span><span class="n">cpd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">])</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Заметим, что по умолчанию, распределение фактора (атрибут <cite>cpd</cite>) принимает значения, соответствующие
равномерному распределению. Так что последние две строчки в данном примере можно было бы опустить.</p>
</div>
<p>Факторы удобны для использования в вероятностных графических моделях тем, что на них определены некоторые операции,
часто выполняемые в процессе логического вывода, в довольно общей форме, что позволяет использовать их как
элементарные объекты для построения логических сетей.</p>
<p>Также, факторы могут представлять условные вероятности. Рассмотрим пример из медицинской диагностики. Определим
бинарную переменную с=(«болезнь», {«нет», «есть»}) и бинарную переменную
t=(«тест», {«положительный», «отрицательный»}). Переменная с показывает, есть ли у пациента определенное
заболевание. а переменная t – результат диагностического теста. Допустим, что априорная вероятность данного
заболевания равна 1%. Сконструируем фактор С=(«P(c)», {c}, {0.99, 0.01}). Очевидно, что вероятность получения
определенного результата теста зависит от того, есть ли данное заболевание у пациента, или нет, то есть мы
предполагаем известной вероятность P(t|c). Допустим, что вероятность получения положительного результата теста
равна 90%. Соответственно, вероятность ложноотрицательного результата равна 0,1. Вероятность получить отрицательный
результат при отсутствии заболевания равна 0,8, а вероятность ложноположительного результата – 0,2.
Создадим фактор, представляющий данную условную вероятность:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">c</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;C&#39;</span><span class="p">,</span> <span class="n">terms</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;no&#39;</span><span class="p">,</span> <span class="s">&#39;yes&#39;</span><span class="p">])</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;T&#39;</span><span class="p">,</span> <span class="n">terms</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;pos&#39;</span><span class="p">,</span> <span class="s">&#39;neg&#39;</span><span class="p">])</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">Factor</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;C&#39;</span><span class="p">,</span> <span class="n">cons</span><span class="o">=</span><span class="p">[</span><span class="n">c</span><span class="p">])</span>
<span class="n">C</span><span class="o">.</span><span class="n">cpd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.99</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">])</span>
<span class="n">T</span> <span class="o">=</span> <span class="n">Factor</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;T|C&#39;</span><span class="p">,</span> <span class="n">cons</span><span class="o">=</span><span class="p">[</span><span class="n">t</span><span class="p">],</span> <span class="n">cond</span><span class="o">=</span><span class="p">[</span><span class="n">c</span><span class="p">])</span>
<span class="n">T</span><span class="o">.</span><span class="n">cpd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">]])</span>
</pre></div>
</div>
<p>Синтаксис:</p>
<blockquote>
<div><p>Создадим два фактора, представляющих распределение двух переменных: P(A) и P(B|A).
Первая переменная имеет безусловное распределение, значение второй зависит от значения первой.</p>
<p>Подготовка переменных (могут быть как дискретные, так и со связанным классификатором):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyinference.fuzzy</span> <span class="kn">import</span> <span class="nb">set</span> <span class="k">as</span> <span class="n">fuzzy_set</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="n">terms</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;low&#39;</span><span class="p">,</span> <span class="s">&#39;high&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fs</span> <span class="o">=</span> <span class="n">fuzzy_set</span><span class="o">.</span><span class="n">Partition</span><span class="p">(</span><span class="n">peaks</span><span class="o">=</span><span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="n">terms</span><span class="o">=</span><span class="n">fs</span><span class="p">)</span>
</pre></div>
</div>
<p>Создание факторов:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">Factor</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="n">cons</span><span class="o">=</span><span class="p">[</span><span class="n">a</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">Factor</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;B|A&#39;</span><span class="p">,</span> <span class="n">cons</span><span class="o">=</span><span class="p">[</span><span class="n">b</span><span class="p">],</span> <span class="n">cond</span><span class="o">=</span><span class="p">[</span><span class="n">a</span><span class="p">])</span>
</pre></div>
</div>
</div></blockquote>
<dl class="docutils">
<dt>Поля класса:</dt>
<dd><p class="first">name (<cite>str</cite>): имя фактора</p>
<p>cond (<cite>list</cite>): список условных переменных</p>
<p>cons (<cite>list</cite>): список подусловных переменных</p>
<p>vars (<cite>list</cite>): список всех переменных фактора (объединение предыдущих двух)</p>
<dl class="docutils">
<dt>shape (<cite>tuple</cite>): кортеж мощностей всех переменных фактора (сохраняя порядок атрибута <cite>vars</cite>).</dt>
<dd>Соответствует форме массива <cite>cpd</cite>.</dd>
</dl>
<p class="last">cpd (<tt class="xref py py-class docutils literal"><span class="pre">numpy.array</span></tt>): массив, хранящий распределение условной вероятности фактора.</p>
</dd>
<dt>Именованные параметры:</dt>
<dd><p class="first">name (<cite>str</cite>): имя фактора</p>
<p>cons (<cite>list</cite>): массив подусловных переменных</p>
<p class="last">cond (<cite>list</cite>): массив условных переменных</p>
</dd>
<dt>Исключения:</dt>
<dd>AttributeError: ошибка возникает, если массив подусловных переменных (cons) пуст</dd>
</dl>
<dl class="method">
<dt id="pyinference.inference.factor.Factor.divide">
<tt class="descname">divide</tt><big>(</big><em>other</em><big>)</big><a class="reference internal" href="_modules/pyinference/inference/factor.html#Factor.divide"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyinference.inference.factor.Factor.divide" title="Permalink to this definition">¶</a></dt>
<dd><p>Реализует деление факторов.</p>
<p>Деление факторов позволяет получить условное распределение из безусловного:</p>
<p>F(A,B) / F(B) = F(A|B)</p>
<p>Может вызываться как метод (<tt class="docutils literal"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">f1.divide(f2)</span></tt>) или как оператор &#8220;/&#8221; (<tt class="docutils literal"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">f1</span> <span class="pre">/</span> <span class="pre">f2</span></tt>).</p>
<dl class="docutils">
<dt>Синтаксис:</dt>
<dd><div class="first last highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;C&#39;</span><span class="p">,</span> <span class="n">terms</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;no&#39;</span><span class="p">,</span> <span class="s">&#39;yes&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;T&#39;</span><span class="p">,</span> <span class="n">terms</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;pos&#39;</span><span class="p">,</span> <span class="s">&#39;neg&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">Factor</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;C&#39;</span><span class="p">,</span> <span class="n">cons</span><span class="o">=</span><span class="p">[</span><span class="n">c</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span><span class="o">.</span><span class="n">cpd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.99</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span> <span class="o">=</span> <span class="n">Factor</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;T|C&#39;</span><span class="p">,</span> <span class="n">cons</span><span class="o">=</span><span class="p">[</span><span class="n">t</span><span class="p">],</span> <span class="n">cond</span><span class="o">=</span><span class="p">[</span><span class="n">c</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span><span class="o">.</span><span class="n">cpd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">C</span> <span class="o">*</span> <span class="n">T</span><span class="p">)</span> <span class="o">/</span> <span class="n">C</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s">&quot;</span><span class="si">%0.3f</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">p</span><span class="o">.</span><span class="n">cpd</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="go">&#39;0.200&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">vars</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
</dd>
<dt>Параметры:</dt>
<dd>other (<a class="reference internal" href="#pyinference.inference.factor.Factor" title="pyinference.inference.factor.Factor"><tt class="xref py py-class docutils literal"><span class="pre">Factor</span></tt></a>): фактор-делитель.</dd>
<dt>Возвращает:</dt>
<dd>Фактор-частное двух исходных</dd>
<dt>Исключения:</dt>
<dd><dl class="first docutils">
<dt>NotImplementedError: ошибка возникает, когда:</dt>
<dd><ul class="first last simple">
<li>делитель имеет условные переменные;</li>
<li>некоторые подусловные переменные делителя отсутствуют среди подусловных переменных делимого</li>
</ul>
</dd>
</dl>
<p class="last">TypeError: ошибка возникает, когда второй операнд имеет неподдерживаемый тип.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyinference.inference.factor.Factor.marginal">
<tt class="descname">marginal</tt><big>(</big><em>var</em><big>)</big><a class="reference internal" href="_modules/pyinference/inference/factor.html#Factor.marginal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyinference.inference.factor.Factor.marginal" title="Permalink to this definition">¶</a></dt>
<dd><p>Выполняет маргинализацию переменной из фактора.</p>
<p>Маргинализация позволяет исключить переменную из области определения фактора, просуммировав соответствующие
значения назначений маргинализируемого фактора. Маргинализация является основой алгоритма variable elimination:</p>
<ul class="simple">
<li>F(A,B,C) - B = F(A,C)</li>
<li>F(A,C|B) - B = F(A,C)</li>
<li>F(A,B|C) - B = F(A|C)</li>
</ul>
<p>Может вызываться как метод (<tt class="docutils literal"><span class="pre">m</span> <span class="pre">=</span> <span class="pre">f1.marginal(var)</span></tt>) или как оператор &#8220;-&#8221; (<tt class="docutils literal"><span class="pre">m</span> <span class="pre">=</span> <span class="pre">f1</span> <span class="pre">-</span> <span class="pre">var</span></tt>).</p>
<dl class="docutils">
<dt>Синтаксис:</dt>
<dd><div class="first last highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;C&#39;</span><span class="p">,</span> <span class="n">terms</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;no&#39;</span><span class="p">,</span> <span class="s">&#39;yes&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;T&#39;</span><span class="p">,</span> <span class="n">terms</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;pos&#39;</span><span class="p">,</span> <span class="s">&#39;neg&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">Factor</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;C&#39;</span><span class="p">,</span> <span class="n">cons</span><span class="o">=</span><span class="p">[</span><span class="n">c</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span><span class="o">.</span><span class="n">cpd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.99</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span> <span class="o">=</span> <span class="n">Factor</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;T|C&#39;</span><span class="p">,</span> <span class="n">cons</span><span class="o">=</span><span class="p">[</span><span class="n">t</span><span class="p">],</span> <span class="n">cond</span><span class="o">=</span><span class="p">[</span><span class="n">c</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span><span class="o">.</span><span class="n">cpd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">T</span> <span class="o">-</span> <span class="n">c</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">cpd</span>
<span class="go">array([ 1.1,  0.9])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">vars</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
</dd>
<dt>Параметры:</dt>
<dd><dl class="first last docutils">
<dt>var (<tt class="xref py py-class docutils literal"><span class="pre">Variable</span></tt> or <cite>list</cite>): маргинализуемая (исключаемая) переменная.</dt>
<dd>Также в данный метод может передаваться список исключаемых переменных.</dd>
</dl>
</dd>
<dt>Возвращает:</dt>
<dd>Маргинализированный фактор</dd>
<dt>Исключения:</dt>
<dd><cite>TypeError</cite>: ошибка возникает, когда второй операнд имеет неподдерживаемый тип.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyinference.inference.factor.Factor.product">
<tt class="descname">product</tt><big>(</big><em>other</em><big>)</big><a class="reference internal" href="_modules/pyinference/inference/factor.html#Factor.product"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyinference.inference.factor.Factor.product" title="Permalink to this definition">¶</a></dt>
<dd><p>Реализует произведение факторов.</p>
<p>Произведение факторов объединяет области определения двух факторов. Значением для каждого назначения является
произведение соответствующих назначений множителей:</p>
<ul class="simple">
<li>F(A) * F(B) = F(A,B)</li>
<li>F(A,|B) * F(B) = F(A,B)</li>
<li>F(A,B|C) * F(D|C) = F(A,B,D|C)</li>
<li>F(A,B|C) * F(D,C) = F(A,B,C,D)</li>
<li>None * F(A) = F(A)</li>
</ul>
<p>Может вызываться как метод (<tt class="docutils literal"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">f1.product(f2)</span></tt>) или как оператор &#8220;*&#8221; (<tt class="docutils literal"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">f1</span> <span class="pre">*</span> <span class="pre">f2</span></tt>).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Также первым операндом произведения может выступать None (<tt class="docutils literal"><span class="pre">None</span> <span class="pre">*</span> <span class="pre">f1</span></tt>). Тогда метод вернет второй операнд.
Это сделано для удобства множественного произведения.</p>
</div>
<dl class="docutils">
<dt>Синтаксис:</dt>
<dd><div class="first last highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;C&#39;</span><span class="p">,</span> <span class="n">terms</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;no&#39;</span><span class="p">,</span> <span class="s">&#39;yes&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;T&#39;</span><span class="p">,</span> <span class="n">terms</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;pos&#39;</span><span class="p">,</span> <span class="s">&#39;neg&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">Factor</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;C&#39;</span><span class="p">,</span> <span class="n">cons</span><span class="o">=</span><span class="p">[</span><span class="n">c</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span><span class="o">.</span><span class="n">cpd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.99</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span> <span class="o">=</span> <span class="n">Factor</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;T|C&#39;</span><span class="p">,</span> <span class="n">cons</span><span class="o">=</span><span class="p">[</span><span class="n">t</span><span class="p">],</span> <span class="n">cond</span><span class="o">=</span><span class="p">[</span><span class="n">c</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span><span class="o">.</span><span class="n">cpd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">T</span> <span class="o">*</span> <span class="n">C</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s">&quot;</span><span class="si">%0.3f</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">p</span><span class="o">.</span><span class="n">cpd</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="go">&#39;0.198&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">vars</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
</dd>
<dt>Параметры:</dt>
<dd>other (<a class="reference internal" href="#pyinference.inference.factor.Factor" title="pyinference.inference.factor.Factor"><tt class="xref py py-class docutils literal"><span class="pre">Factor</span></tt></a>): фактор-множитель.</dd>
<dt>Возвращает:</dt>
<dd>Фактор-произведение двух исходных</dd>
<dt>Исключения:</dt>
<dd><p class="first"><cite>AttributeError</cite>: ошибка возникает, когда исключаемая переменная не входит в исходный фактор.</p>
<p class="last"><cite>TypeError</cite>: ошибка возникает, когда второй операнд имеет неподдерживаемый тип.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyinference.inference.net">
<span id="pyinference-inference-net-module"></span><h2>pyinference.inference.net module<a class="headerlink" href="#module-pyinference.inference.net" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pyinference.inference.net.Net">
<em class="property">class </em><tt class="descclassname">pyinference.inference.net.</tt><tt class="descname">Net</tt><big>(</big><em>name=''</em>, <em>nodes=None</em><big>)</big><a class="reference internal" href="_modules/pyinference/inference/net.html#Net"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyinference.inference.net.Net" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Данный класс реализует смешанную сеть вывода.</p>
<p>Основным назначением данного класса является выполнение запросов к сети.
Сеть формируется как набор факторов, характеризующих совместное распределение значений некоторого набора переменных.</p>
<p>Сети Байса традиционно представляются в виде графа, в котором вершины представляют переменные, входящие в сеть,
а ребра – причинно-следственные связи, причем ребро направлено от причины к следствию. Это очень наглядное
представление является одним из главных достоинств вероятностных графических моделей и позволяет отобразить
условную вероятность в виде взаимосвязей переменных и факторов, а также зачастую построить граф по экспертным или
эмпирическим данным для моделирования распределения вероятностей. В графе наглядно видна иерархичность условной
вероятности. Если некая переменная X зависит от переменной Y, то переменная Y будет среди родителей переменной X
на графе.</p>
<p>Запрос к байесовской сети выглядит следующим образом: каково распределение полной вероятности набора переменных Q,
при условии, что набор переменных E принимает назначение q? Множество переменных Q называется запросом (query) или
целевыми переменными и может состоять из одной и более переменных. Множество условий E называется
наблюдения (evidence) или наблюдаемыми переменными и, в общем случае, может быть пустым. Множества Q и E не должны
пересекаться. Множество переменных, входящих в байесовскую сеть, но не входящих во множества Q и E называется
скрытые (hidden) переменные. Семантика этих множеств довольно очевидна. Запрос – это целевые переменные, которые
нас интересуют, исходя из контекста конкретной задачи. Наблюдение – это те переменные, значения которых мы можем
измерить или предсказать. Скрытые переменные не являются ни тем, ни другим, но могут оказывать неявное влияние на
запрос и/или на наблюдения. В таких обозначениях использование сети Байеса для логического вывода сводится к
вычислению вероятности P(Q|E).</p>
<p>Достоинством сетей Байеса является универсальность. Единожды сконструированная, сеть может использоваться для
вычисления любых корректных запросов на области ее определения, то есть не нужно изменять конструкцию сети,
чтобы выполнять запросы определенного вида. Запрос является корректным, если выполняются два условия:
- все переменные входящие в множества наблюдений и запросов входят в область определения сети;
- множества Q и E не пересекаются.</p>
<p>Итак, каждый запрос разбивает множество переменных области определения сети на три непересекающихся множества:
Q, E и H. Значение любого запроса к Байсовской сети на этих множествах может быть вычислен только из фактора,
представляющего распределение полной вероятности P(Q,E,H).</p>
<dl class="docutils">
<dt>Синтаксис:</dt>
<dd><div class="first last highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyinference.inference.variable</span> <span class="kn">import</span> <span class="n">Variable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyinference.inference.factor</span> <span class="kn">import</span> <span class="n">Factor</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;C&#39;</span><span class="p">,</span> <span class="n">terms</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;no&#39;</span><span class="p">,</span> <span class="s">&#39;yes&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;T&#39;</span><span class="p">,</span> <span class="n">terms</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;pos&#39;</span><span class="p">,</span> <span class="s">&#39;neg&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c_node</span> <span class="o">=</span> <span class="n">Factor</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;C&#39;</span><span class="p">,</span> <span class="n">cons</span><span class="o">=</span><span class="p">[</span><span class="n">c</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c_node</span><span class="o">.</span><span class="n">cpd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.99</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t_node</span> <span class="o">=</span> <span class="n">Factor</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;T|C&#39;</span><span class="p">,</span> <span class="n">cons</span><span class="o">=</span><span class="p">[</span><span class="n">t</span><span class="p">],</span> <span class="n">cond</span><span class="o">=</span><span class="p">[</span><span class="n">c</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t_node</span><span class="o">.</span><span class="n">cpd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bn</span> <span class="o">=</span> <span class="n">Net</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;Cancer&#39;</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="p">[</span><span class="n">c_node</span><span class="p">,</span> <span class="n">t_node</span><span class="p">])</span>
</pre></div>
</div>
</dd>
<dt>Поля класса:</dt>
<dd><p class="first">name (<cite>str</cite>): имя сети;</p>
<p class="last">nodes(<cite>list</cite>): список факторов, составляющих сеть.</p>
</dd>
<dt>Именованные параметры:</dt>
<dd><p class="first">name (<cite>str</cite>): имя сети;</p>
<dl class="last docutils">
<dt>nodes (<cite>list</cite>): список факторов, составляющих сеть.</dt>
<dd><p class="first">Передача конструктору списока <tt class="docutils literal"><span class="pre">bn</span> <span class="pre">=</span> <span class="pre">Node(name='sample</span> <span class="pre">net',</span> <span class="pre">nodes=a_list)</span></tt> эквивалентна использованию
метода <a class="reference internal" href="#pyinference.inference.net.Net.add_node" title="pyinference.inference.net.Net.add_node"><tt class="xref py py-func docutils literal"><span class="pre">add_node()</span></tt></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">bn</span> <span class="o">=</span> <span class="n">Net</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;sample net&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">a_list</span><span class="p">:</span>
    <span class="n">bn</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
</pre></div>
</div>
<p class="last">Поэтому при использовании конструктора может генерироваться исключение метода <a class="reference internal" href="#pyinference.inference.net.Net.add_node" title="pyinference.inference.net.Net.add_node"><tt class="xref py py-func docutils literal"><span class="pre">add_node()</span></tt></a>.
В частности, такое может произойти при неверном порядке факторов в передаваемом списке. Поэтому,
рекомендуется использовать конструктор без второго параметра, а факторы в сеть добавлять явно.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="pyinference.inference.net.Net.add_node">
<tt class="descname">add_node</tt><big>(</big><em>factor</em><big>)</big><a class="reference internal" href="_modules/pyinference/inference/net.html#Net.add_node"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyinference.inference.net.Net.add_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Метод добавляет фактор к сети.</p>
<p>В процессе добавления фактора к сети производится проверка корректности. Он заключается в том, что мы не можем
добаить к сети фактор, если его родителя в сети нет. Например, у нас есть два фактора: F(C) и G(T|C).
Так как второй фактор (G) представляет условную вероятность, его родителем должен быть фактор, определяющий
распределение вероятности переменной C, то есть, фактор F. Таким образом, если мы <em>сначала</em> попытаемся добавить
к сети фактор G, то получим ошибку, так как его родителя в сети нет. Однако, если сперва добавить фактор
F, а уже <em>затем</em> фактор G, то проблем не возникнет.
Такая проверка гарантирует корректность графа, представляющего данную сеть.</p>
<dl class="docutils">
<dt>Синтаксис:</dt>
<dd><div class="first last highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyinference.inference.variable</span> <span class="kn">import</span> <span class="n">Variable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyinference.inference.factor</span> <span class="kn">import</span> <span class="n">Factor</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;C&#39;</span><span class="p">,</span> <span class="n">terms</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;no&#39;</span><span class="p">,</span> <span class="s">&#39;yes&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;T&#39;</span><span class="p">,</span> <span class="n">terms</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;pos&#39;</span><span class="p">,</span> <span class="s">&#39;neg&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c_node</span> <span class="o">=</span> <span class="n">Factor</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;C&#39;</span><span class="p">,</span> <span class="n">cons</span><span class="o">=</span><span class="p">[</span><span class="n">c</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c_node</span><span class="o">.</span><span class="n">cpd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.99</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t_node</span> <span class="o">=</span> <span class="n">Factor</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;T|C&#39;</span><span class="p">,</span> <span class="n">cons</span><span class="o">=</span><span class="p">[</span><span class="n">t</span><span class="p">],</span> <span class="n">cond</span><span class="o">=</span><span class="p">[</span><span class="n">c</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t_node</span><span class="o">.</span><span class="n">cpd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bn</span> <span class="o">=</span> <span class="n">Net</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;Cancer&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bn</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">c_node</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bn</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">t_node</span><span class="p">)</span>
</pre></div>
</div>
</dd>
<dt>Параметры:</dt>
<dd>factor (<tt class="xref py py-class docutils literal"><span class="pre">Factor</span></tt>): добавляемый фактор</dd>
<dt>Исключения:</dt>
<dd><cite>AttributeError</cite>: ошибка возникает, если при добавлении фактора провалилась проверка корректности.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyinference.inference.net.Net.joint">
<tt class="descname">joint</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/pyinference/inference/net.html#Net.joint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyinference.inference.net.Net.joint" title="Permalink to this definition">¶</a></dt>
<dd><p>Рассчитывает распределение совместной вероятности всех переменных сети.</p>
<dl class="docutils">
<dt>Синтаксис:</dt>
<dd><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyinference.inference.variable</span> <span class="kn">import</span> <span class="n">Variable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyinference.inference.factor</span> <span class="kn">import</span> <span class="n">Factor</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;C&#39;</span><span class="p">,</span> <span class="n">terms</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;no&#39;</span><span class="p">,</span> <span class="s">&#39;yes&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;T&#39;</span><span class="p">,</span> <span class="n">terms</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;pos&#39;</span><span class="p">,</span> <span class="s">&#39;neg&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c_node</span> <span class="o">=</span> <span class="n">Factor</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;C&#39;</span><span class="p">,</span> <span class="n">cons</span><span class="o">=</span><span class="p">[</span><span class="n">c</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c_node</span><span class="o">.</span><span class="n">cpd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.99</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t_node</span> <span class="o">=</span> <span class="n">Factor</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;T|C&#39;</span><span class="p">,</span> <span class="n">cons</span><span class="o">=</span><span class="p">[</span><span class="n">t</span><span class="p">],</span> <span class="n">cond</span><span class="o">=</span><span class="p">[</span><span class="n">c</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t_node</span><span class="o">.</span><span class="n">cpd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bn</span> <span class="o">=</span> <span class="n">Net</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;Cancer&#39;</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="p">[</span><span class="n">c_node</span><span class="p">,</span> <span class="n">t_node</span><span class="p">])</span>
</pre></div>
</div>
<div class="last highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">j</span> <span class="o">=</span> <span class="n">bn</span><span class="o">.</span><span class="n">joint</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">j</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">j</span><span class="o">.</span><span class="n">vars</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s">&quot;</span><span class="si">%0.3f</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">j</span><span class="o">.</span><span class="n">cpd</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="go">&#39;0.198&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s">&quot;</span><span class="si">%0.3f</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">j</span><span class="o">.</span><span class="n">cpd</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="go">&#39;0.001&#39;</span>
</pre></div>
</div>
</dd>
<dt>Возвращает:</dt>
<dd>Фактор (<tt class="xref py py-class docutils literal"><span class="pre">Factor</span></tt>), представляющий рапределение полной вероятности всех
переменных сети.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyinference.inference.net.Net.query">
<tt class="descname">query</tt><big>(</big><em>query=None</em>, <em>evidence=None</em><big>)</big><a class="reference internal" href="_modules/pyinference/inference/net.html#Net.query"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyinference.inference.net.Net.query" title="Permalink to this definition">¶</a></dt>
<dd><p>Выполняет запрос к сети вывода.</p>
<dl class="docutils">
<dt>Синтаксис:</dt>
<dd><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyinference.inference.variable</span> <span class="kn">import</span> <span class="n">Variable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyinference.inference.factor</span> <span class="kn">import</span> <span class="n">Factor</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;C&#39;</span><span class="p">,</span> <span class="n">terms</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;no&#39;</span><span class="p">,</span> <span class="s">&#39;yes&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;T&#39;</span><span class="p">,</span> <span class="n">terms</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;pos&#39;</span><span class="p">,</span> <span class="s">&#39;neg&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c_node</span> <span class="o">=</span> <span class="n">Factor</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;C&#39;</span><span class="p">,</span> <span class="n">cons</span><span class="o">=</span><span class="p">[</span><span class="n">c</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c_node</span><span class="o">.</span><span class="n">cpd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.99</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t_node</span> <span class="o">=</span> <span class="n">Factor</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;T|C&#39;</span><span class="p">,</span> <span class="n">cons</span><span class="o">=</span><span class="p">[</span><span class="n">t</span><span class="p">],</span> <span class="n">cond</span><span class="o">=</span><span class="p">[</span><span class="n">c</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t_node</span><span class="o">.</span><span class="n">cpd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bn</span> <span class="o">=</span> <span class="n">Net</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;Cancer&#39;</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="p">[</span><span class="n">c_node</span><span class="p">,</span> <span class="n">t_node</span><span class="p">])</span>
</pre></div>
</div>
<div class="last highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">bn</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">query</span><span class="o">=</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="n">evidence</span><span class="o">=</span><span class="p">[</span><span class="n">t</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">vars</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="o">.</span><span class="n">cond</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span>
<span class="go">&#39;T&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="o">.</span><span class="n">cons</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span>
<span class="go">&#39;C&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s">&quot;</span><span class="si">%0.3f</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">q</span><span class="o">.</span><span class="n">cpd</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="go">&#39;0.957&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s">&quot;</span><span class="si">%0.3f</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">q</span><span class="o">.</span><span class="n">cpd</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="go">&#39;0.001&#39;</span>
</pre></div>
</div>
</dd>
<dt>Именованные параметры:</dt>
<dd><p class="first">query (<cite>list</cite>): список переменных (<tt class="xref py py-class docutils literal"><span class="pre">Variable</span></tt>) запроса;</p>
<p class="last">evidence (<cite>list</cite>): список переменных (<tt class="xref py py-class docutils literal"><span class="pre">Variable</span></tt>) свидетельств.</p>
</dd>
<dt>Возвращает:</dt>
<dd>Фактор (<tt class="xref py py-class docutils literal"><span class="pre">Factor</span></tt>), представляющий рапределение условной вероятности,
где условными переменными являются наблюдения (evidence), а подусловными - переменные запроса (query):
F(Q|E).</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyinference.inference.variable">
<span id="pyinference-inference-variable-module"></span><h2>pyinference.inference.variable module<a class="headerlink" href="#module-pyinference.inference.variable" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pyinference.inference.variable.Variable">
<em class="property">class </em><tt class="descclassname">pyinference.inference.variable.</tt><tt class="descname">Variable</tt><big>(</big><em>name=''</em>, <em>terms=None</em><big>)</big><a class="reference internal" href="_modules/pyinference/inference/variable.html#Variable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyinference.inference.variable.Variable" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Класс реализует переменную</p>
<p>Переменная представляет собой некий параметр, могущий иметь определенный набор значений.
Набор значений переменной может задаваться двумя способами.
Во-первых, можно задать списком. В таком случае, этот список следует передать как аргумент terms конструктора.
Во-вторых, с переменной может быть ассоциирован нечеткий классификатор (см.
<a class="reference internal" href="pyinference.fuzzy.html#pyinference.fuzzy.set.FuzzySet" title="pyinference.fuzzy.set.FuzzySet"><tt class="xref py py-class docutils literal"><span class="pre">pyinference.fuzzy.set.FuzzySet</span></tt></a>).
Тогда передать конструктору следует его.</p>
<p>Переменная в байесовском моделировании – некая сущность, обладающая именем и областью определения.
Обычно, рассматриваются переменные двух типов: дискретные и непрерывные. Дискретные переменные принимают значения
из некоторого конечного множества X, а непрерывные – определены на некотором подмножестве множества действительных
чисел. В общем случае, переменная определяется упорядоченной парой V=(N, X), где N – имя переменной, а X –
множество возможных значений.</p>
<p>Примером случайной переменной может быть результат подбрасывания монеты в таком случае областью ее определения
будет множество {“орел”, “решка”}. В общем случае, конкретные значения переменной не имеют синтаксического значения
(имеют место только семантически, то есть по смыслу) и их обычно заменяют соответствующим по числу элементов
подмножество множества натуральных числе. То есть в нашем примере, можно обозначить значение «решка» за 0, а
«орел» - за 1, и тогда область определения переменной будет {0, 1}.</p>
<p>Построим данную переменную с использованием класса Variable:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">coin</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;coin&quot;</span><span class="p">,</span> <span class="n">terms</span><span class="o">=</span><span class="p">[</span><span class="s">&quot;орел&quot;</span><span class="p">,</span> <span class="s">&quot;решка&quot;</span><span class="p">])</span>
</pre></div>
</div>
<p>Частным и довольно распространенным случаем дискретной переменной является переменная, способная принимать только
два значения. Такая переменная называется бинарной. В примере выше – результат подбрасывания монеты – бинарная
переменная.</p>
<p>Наиболее важным производным свойством дискретной переменной является мощность переменной – количество значений,
которые она может принимать. Мощность бинарной переменной равна двум.</p>
<dl class="docutils">
<dt>Синтаксис:</dt>
<dd><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pyinference.inference.variable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="n">terms</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="s">&#39;low&#39;</span>
</pre></div>
</div>
<div class="last highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyinference.fuzzy</span> <span class="kn">import</span> <span class="nb">set</span> <span class="k">as</span> <span class="n">fuzzy_set</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fs</span> <span class="o">=</span> <span class="n">fuzzy_set</span><span class="o">.</span><span class="n">Partition</span><span class="p">(</span><span class="n">peaks</span><span class="o">=</span><span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="n">terms</span><span class="o">=</span><span class="n">fs</span><span class="p">)</span>
</pre></div>
</div>
</dd>
<dt>Поля класса:</dt>
<dd><p class="first">card (<cite>int</cite>): мощность переменной (количество значений)</p>
<p>classifier(<cite>dict</cite> or <a class="reference internal" href="pyinference.fuzzy.html#pyinference.fuzzy.set.FuzzySet" title="pyinference.fuzzy.set.FuzzySet"><tt class="xref py py-class docutils literal"><span class="pre">pyinference.fuzzy.set.FuzzySet</span></tt></a>): связанный с переменной классификатор</p>
<p>name (<cite>str</cite>): имя переменной</p>
<p>terms (<cite>list</cite>): список значений переменной (терм-множество)</p>
<p class="last">value (<cite>object</cite>): текущее значение переемнной</p>
</dd>
<dt>Именованные параметры:</dt>
<dd><p class="first">name (<cite>str</cite>): имя переменной</p>
<p class="last">terms (<cite>list</cite> or <cite>dict</cite> or <a class="reference internal" href="pyinference.fuzzy.html#pyinference.fuzzy.set.FuzzySet" title="pyinference.fuzzy.set.FuzzySet"><tt class="xref py py-class docutils literal"><span class="pre">pyinference.fuzzy.set.FuzzySet</span></tt></a>): набор значений переменной</p>
</dd>
<dt>Исключения:</dt>
<dd><cite>TypeError</cite>: ошибка возникает, если агрумент terms имеет неподдерживаемый тип.</dd>
</dl>
<dl class="method">
<dt id="pyinference.inference.variable.Variable.equals">
<tt class="descname">equals</tt><big>(</big><em>value</em><big>)</big><a class="reference internal" href="_modules/pyinference/inference/variable.html#Variable.equals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyinference.inference.variable.Variable.equals" title="Permalink to this definition">¶</a></dt>
<dd><p>Проверка переменной на равенство значению.</p>
<p>Данный метод принимает некое значение и вычисляет меру сходства его со значением атрибута <cite>value</cite>.</p>
<dl class="docutils">
<dt>Синтаксис:</dt>
<dd><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pyinference.inference.variable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="n">terms</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="s">&#39;low&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s">&#39;</span><span class="si">%.2f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">a</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="s">&#39;low&#39;</span><span class="p">)</span>
<span class="go">&#39;1.00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s">&#39;</span><span class="si">%.2f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">a</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="s">&#39;high&#39;</span><span class="p">)</span>
<span class="go">&#39;0.00&#39;</span>
</pre></div>
</div>
<div class="last highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyinference.fuzzy</span> <span class="kn">import</span> <span class="nb">set</span> <span class="k">as</span> <span class="n">fuzzy_set</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pyinference.inference.variable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fs</span> <span class="o">=</span> <span class="n">fuzzy_set</span><span class="o">.</span><span class="n">Partition</span><span class="p">(</span><span class="n">peaks</span><span class="o">=</span><span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="n">terms</span><span class="o">=</span><span class="n">fs</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s">&#39;</span><span class="si">%.2f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">b</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">&#39;1.00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="s">&#39;1&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s">&#39;</span><span class="si">%.2f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">b</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="mf">0.25</span><span class="p">)</span>
<span class="go">&#39;0.50&#39;</span>
</pre></div>
</div>
</dd>
<dt>Параметры:</dt>
<dd>value (<cite>object</cite>): Значение переменной.
Может быть как элементом терм-множества занчений, явно перечисленного в атрибуте <cite>terms</cite> класса,
так и элементом области определения связанного с этой переменной классификатора.</dd>
<dt>Возвращает:</dt>
<dd>Действительное число x, где -1.0 &lt;= x &lt;= 1.0, характеризующую меру сходства переданного и текущего
значений переменной.</dd>
<dt>Исключения:</dt>
<dd><cite>AttributeError</cite>: если текущее значение переменной не было задано до вызова данного метода.</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyinference.inference">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-pyinference.inference" title="Permalink to this headline">¶</a></h2>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">pyinference.inference package</a><ul>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-pyinference.inference.factor">pyinference.inference.factor module</a></li>
<li><a class="reference internal" href="#module-pyinference.inference.net">pyinference.inference.net module</a></li>
<li><a class="reference internal" href="#module-pyinference.inference.variable">pyinference.inference.variable module</a></li>
<li><a class="reference internal" href="#module-pyinference.inference">Module contents</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="pyinference.fuzzy.html"
                        title="previous chapter">pyinference.fuzzy package</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/pyinference.inference.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="pyinference.fuzzy.html" title="pyinference.fuzzy package"
             >previous</a> |</li>
        <li><a href="index.html">pyinference 0.4.0 documentation</a> &raquo;</li>
          <li><a href="pyinference.html" >pyinference package</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014, sejros.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>